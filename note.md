# Hello World

## 程序框架

```c
#include <stdio.h>

int main()
{
    return 0;
}
```

所有程序都需要有的一段框架，在开始时先将框架写好再继续在框架中做接下来该做的事。

## 输出

```c
printf("Hello World!\n")
```

`""`里的内容叫做字符串，printf会把其中的内容原封不动的输出，  
`\n`表示需要在输出的结果后面换一行。

## 程序中的错误

编译的时候发现的错误所在的地方会以红色的底表示出来；  
具体的错误原因列在下方的窗口里，但很多时候错误提示不会那么好懂。

- 对C语言来说换行和空格不代表任何事情，所以有时候有错误提示要往前或者往后看看。
  不要用中文输入法来输入程序。

# 做计算

```c
printf("%d",12+34)
```

`printf()`是输出双引号中的内容，但是如果是`%d`，输出的就不是`%d`了，而是输出双引号之后的值。  
`%d`以及后面的值要加逗号隔开。

如果写成 `printf("12+34=%d",12+34)`会输出为`12+34=46`

- 这里四则运算都可以做。

| 四则运算 | C符号 | 意义 |
|------|-----|----|
| +    | +   | 加  |
| -    | -   | 减  |
| x    | *   | 乘  |
| ÷    | /   | 除  |
|      | %   | 取余 |
| ()   | ()  | 括号 |

- `%`取余表示取两个数相除以后的余数。

## 错误示范

```c
#include <stdio.h>

int main()
{

	printf("3%4=%d",3%4); 
	
	return 0;
}
```

本意是想得出 `3` 除以 `4` 的取余，结果输出结果为 `3=3`。  
原因分析：
在 `printf()` 中，`%` 不是普通字符，是用来引出格式说明符；

- `%d` 是输出一个 `int`，`%s` 是输出字符串，`%f` 是输出浮点数。

在`printf()`中，`%4d` 是输出一个 `int`，占 4 个字符宽度；
但是实际写出的是 `3%4=%d`，那在这里的 `%4` 后没有类型说明符，属于非法格式，大多数编译器会“吞掉” `%4`，什么也不输出；  
于是实际效果变成了`3=3`。

可以改成 `printf("3%%4 = %d\n", 3 % 4)`;

## printf最常用格式符速查表

| 格式符 | 含义        | 对应类型   |
|-----|-----------|--------|
| %d  | 十进制整数     | int    |
| %f  | 浮点数       | double |
| %c  | 字符        | char   |
| %s  | 字符串       | char*  |
| %p  | 地址        | 指针     |
| %%  | 输出 `%` 本身 | 无参数    |

不严谨来说，`int` 是指整数，`double` 是指带小数的数，`char` 是指一个字符，`char*`是指向字符的地址（字符串）。

在C语言中不存在字符串这种基本结构，它的字符串是一串 `char` + `\0`（字符串结束标志）

## printf与char*

```c
	char* p="heello";
	printf("%s\n",p);
```

`p` 指向的是 `h` 的地址，地址里存的内容才是 `h`；  
`printf("%s\n",p)` 的意思是根据 `p` 指向的地址，一直往后读，读到`\0`，然后把所有字符都打出来。

如果是想要提取首字符，可以这么写：

```c
	char* p="heello"; 
	printf("%c\n", *p);
```

`p` 是指地址，而`*p`是指地址里的内容。  
同时还可以用`p+1`来指向下一个地址，`*(p+1)`指向第二个字符。

## 计算器代码（简略且按需修改版）

```c
#include <stdio.h>

int main()
{
	printf("xx+xx=%d",xx+xx);
	printf("xx-xx=%d",xx-xx);
	printf("xx*xx=%d",xx*xx);
	printf("xx/xx=%d",xx/xx);
	printf("xx%%xx=%d",xx%xx);
	
	return 0;
}
```

## 程序外输入

```c
#include <stdio.h>

int main()
{
	int price = 0;

	printf("请输入金额（元）：");
	scanf("%d",&price);

	int change = 100 - price;

	printf("找您%d元。\n",change);
	
	return 0;
}
```

输入也在终端窗口中；  
输入是以行为单位进行的，行的结束标志是你按下了回车键；  
在按下回车键之前，程序不会读到任何东西。

在这个程序之中，输入的数值是放入了变量之中。

`int price = 0;` 这一行就是定义了一个变量，变量的名字是`price`，类型是`int`，初始值是`0`；    
变量是一个保存数据的地方，当我们需要在程序里保存数据时，比如上面的例子中要记录用户输入的价格，就需要一个变量来保存它；  
用一个变量保存了数据，它才能参加到后面的计算中，比如计算找零。

### 变量定义

变量定义的一般形式就是：<类型名称><变量名称>;

- `int price; int amount; int price,amount;`
    - `;`是指这一行结束了，`,`是指这里有两个不同的东西。

变量需要一个名字，变量的名字是一种“标识符”，用于在程序中区分不同的变量。  
标识符有标识符的构造规则。基本的原则是：

1. 标识符只能由字母、数字和下划线组成；
2. 数字不可以出现在第一个位置上；
3. C语言的关键字（有的地方叫它们保留字）不可以用作标识符。
    - 关键字不需要背诵，如果用关键字做标识符，编译器会提示。

### 赋值和初始化

```c
int price = 0;
```

`price = 0` 是一个式子，这里的`=`是一个赋值运算符，表示将`=`
右边的值赋给左边的变量，在定义变量时做的赋值又叫做变量的初始化。  
对C语言来说，赋值和初始化的差别不大。

在数学中，`a=b`表示关系，即`a`和`b`的值一样，是静态的；  
而在程序设计中，`a=b`表示要求计算机做一个动作：将`b`的值赋给`a`；  
在数学中，`a=b`和`b=a`是等价的，而在程序设计中，两者的意思完全相反。

虽然C语言并没有强制要求所有的变量都在定义的地方做初始化，但是所有的变量在第一次被使用之前都应该被赋值一次。

如果没有初始化就直接使用变量，那该变量就是未定义的垃圾值，可能会发生任何结果。  
在机器层这代表了给变量分配了一块内存，但是不修改其内容，那这块内存里到底存着的是什么东西完全不可预测。

初始化是为了让变量从一个能解释的通的状态开始，`int price = 0`;的意思就是我明确规定：这个变量一开始代表”什么都没有“。
`0`并不是一个随便选的数字，而是逻辑上正确的起点，这样财富和人类的理解。

### 表达式

`=`是数字运算符，有运算符的式子就叫做表达式。

### 变量类型

```c
int price = 0;
```

变量的类型是`int`。  
C语言是一种有类型的语言，所有的变量在使用之前必须定义或者声明，所有的变量必须具有确定的数据类型。  
数据类型表示在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。

当有需要储存的数据时，就定义一个对应的变量。

### ANSI C

在C99里，变量不一定要一开始就全部写在函数开头，你可以在代码中用到它之前的任何地方再定义它。  
而传统的ANSI C只能在代码开头的地方定义变量。

例：  
C99：

```c
int price = 0;

printf("请输入金额（元）：");
scanf("%d",&price);

int change = 100 - price;

printf("找您%d元。\n",change);
```

ANSI C：

```c
int price = 0;
int change = 0;
printf("请输入金额（元）：");
scanf("%d",&price);
change = 100 - price;
printf("找您%d元。\n",change);
```

### 读整数

在定义`price`变量之后，该如何将用户输入的值读入进来？  
使用`scanf()`函数将读入的结果赋值给变量`price`，`%d`说明读入一个整数。  
需要注意`price`前面的`&`，需要让`scanf()`读什么东西，就一定要把`&`加到对应变量名字前面。

如果在例子程序中`price`那里输入的不是整数，那`scanf()`会读不到任何东西，会给默认值也就是0。

### 关于scanf

出现在`scanf()`中`""`中的所有东西都是`scanf()`要读的东西，当然`%d`说明它在这里要读一个整数交给后面的一个变量。

```c
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;
	
	scanf("%d %d", &a, &b);
	
	printf("%d %d\n", a, b);
	
	return 0;
}
```

```c
scanf("%d %d", &a, &b); // 如果输入1 2能正常读取；  
scanf("%d,%d", &a, &b); // 如果输入1,2能正常读取；  
scanf("%d %d ", &a, &b); // 如果输入1 2 能正常读取；  
```

`scanf()`格式字符串并不会向用户输出任何内容，而是用于指导函数如何从输入流中读取和解释数据。  

### 常量

`int change = 100 - price;`  
固定不变的数是常数，直接卸载程序里，我们称作直接量。  
更好的方式是定义一个常量：`const int AMOUNT = 100;`。  

```c
#include <stdio.h>

int main()
{
	const int AMOUNT = 100;
	int price = 0;
	
	printf("请输入金额（元）：");
	scanf("%d", &price);
	
	int change = AMOUNT - price;
	
	printf("找您%d元。\n", change);
	
	return 0;
}
```

使用常量给100起一个名字能更容易让人理解100的含义，以及把常量放在代码前面的部分方便之后对程序进行修改。  

`const`是一个修饰符，加在`int`的前面，用来给这个常量加上一个`const（不变的）`的属性。  
这个`const`的属性表示这个变量的值一旦初始化，就不能再修改了。  
一般来说，常量名字是全大写的。  

# 计算身高的程序

```c
#include <stdio.h>

int main()
{
	printf("请分别输入身高的英尺和英寸，""如输入\"5 7\"表示5英尺7英寸：");
	
	int foot;
	int inch;
	
	scanf("%d %d", &foot, &inch);
	
	printf("身高是%f米。\n",(foot + inch / 12) * 0.3048);
	
	return 0;
}
```

以上代码`inch/12`会出现小数部分，而在C语言中两个整数的运算只能是整数，小数部分会被忽略掉，导致每次计算都会有误。  
修改办法：
1. 把`(foot + inch / 12) * 0.3048`改成`(foot + inch / 12.0) * 0.3048`即可解决问题；  
  - 因为当浮点数和整数放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的计算。
2. 把inch定义为double类型的双精度浮点数变量。

> 浮点数时计算机内部表达非整数的一种方式，另一种方式叫做定点数，不过在C语言中不会遇到定点数。  
  人们借用浮点数这个词来表达所有的带小数点的数。
  目前学到的数据类型：
  1. 整数，int，printf("%d",...)，scanf("%d",...)
  2. 带小数点的数，double，printf("%f",...)，scanf("%lf",...)
  
# 表达式  

一个表达式是一系列运算符和算子的组合，用来计算一个值。  
  - 运算符（operator）是指进行运算的动作，比如加法运算符“+”，减法运算符“-”。
  - 算子（operand）是指参与运算的值，这个值可能是常数，也可能是变量，还可能使一个方法的返回值。  
  
## 计算时间差

输入两个时间，每个时间分别输入小时和分钟的值，然后输出两个时间之间的差，也以几小时几分表示。  

```c

int hour1,minute1;
int hour2,minute2;

scanf("%d %d", &hour1, &minute1);
scanf("%d %d", &hour2, &minute2);

```

自写实验版：  
```c
#include <stdio.h>

int main()
{
	int hour1,minute1;
	int hour2,minute2;

	scanf("%d %d", &hour1, &minute1);
	scanf("%d %d", &hour2, &minute2);

	printf("时间差是%d时%d分", hour1-hour2, minute1-minute2);
	
	return 0;
}
```

视频中教的版本：  
```c
#include <stdio.h>

int main()
{
	int hour1,minute1;
	int hour2,minute2;

	scanf("%d %d", &hour1, &minute1);
	scanf("%d %d", &hour2, &minute2);

	int t1 = hour1 * 60 + minute1;
	int t2 = hour2 * 60 + minute2;

	int t = t2 - t1; 
	
	printf("时间差是%d小时%d分", t/60, t%60);
	
	return 0;
}
```

进一步小小改动的版本：  
```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int hour1,minute1;
	int hour2,minute2;

	scanf("%d %d", &hour1, &minute1);
	scanf("%d %d", &hour2, &minute2);

	int t1 = hour1 * 60 + minute1;
	int t2 = hour2 * 60 + minute2;

	int t = abs(t2 - t1); 
	
	printf("时间差是%d小时%d分", t/60, t%60);
	
	return 0;
}
```

# 运算符优先级

## 求平均值

```c
int a,b;

scanf("%d %d", &a, &b);

double c = (a+b)/2.0

printf("%d和%d的平均值=%f\n", a, b, c);
```

## 赋值运算符

赋值也是运算，也有结果。  
赋值是从右往左的，赋值的优先级比其他四则运算低。  

a=b=6在计算机理解中是a=(b=6)  
b=6把6赋给b，同时表达式的值也是6，然后再把这个值赋给a。  

## 嵌入式赋值

```c
int a = 6;  
int b;  
int c = 1+(b=a);
```
这种嵌入式赋值不利于阅读而且容易产生错误。  

## 结合关系

一般自左向右；  
单目+-和赋值=自右向左。  

# 交换变量

## 交换两个变量

如果已经有：
```c
int a = 6;
int b = 5;
```
那如何交换两个变量的值？  

自写版：  
```c
#include <stdio.h>

int main()
{
	int a = 5;
	int b = 6;
	
	int c = a;
	
	printf("a=%d\n",b);
	printf("b=%d",c);

	return 0;
}
```

视频教学版：  
```c
int main()
{
	int a=5;
	int b=6;
	int t;
	t=a;
	a=b;
	b=t;
	printf("a=%d,b=%d\n", a,b);
	return 0;
}
```

# 复合赋值和递增递减

## 复合赋值

5个运算符，`+-*/%`，可以和赋值运算符"="结合起来，形成复合赋值运算符：`+=`、`-=`、`*=`、`/=`和`%=`。  
  - total += 5;
  - total = total + 5;
  - 注意两个运算符中间不要有空格。

```c
total += (sum + 100) / 2;  
total = total + (sum + 100) / 2;
total *= sum + 12;
total = total * (sum + 12);
```
可以看出使用复合赋值运算符时，都是先完成右边的计算，再来做和左边变量的结合。  

## 递增递减运算符

`"++"`和`"--"`是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量。  
这两个运算符分别叫做递增和递减运算符，它们的作用就是给这个变量+1或者-1。  

```c
count++;
count += 1;
count = count + 1;
```

`++`和`--`可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形式。  
`a++`的值是a加1以前的值，而`++a`的值是加了1以后的值，无论哪个，`a`自己的值都加了`1`了。  

```c
int a = 5;
int b = a++; //b得到的是a加1之前的值：5，然后a变成6。
```

视频中的例子：  
```c
#include <stdio.h>

int main()
{
	int a;
	a = 10;
	
	printf("a++=%d\n", a++);
	printf("a=%d\n", a);
	
	printf("++a=%d\n", ++a);
	printf("a=%d\n", a);
	
	return 0;
}
```

`++`，`--`这两个运算符有其历史来源，可以单独使用，但是不要组合进表达式。  
  - 否则表达式会变得十分混乱。
    - 例：`a=b+=c++-d+--e/-f`

> 变量本身在内存中占一个格子，它对应的值也占一个格子。  
  在C语言中，当两个整数相除时，结果也是整数（不是浮点数），小数部分会被直接截断（向下取整方向的截断，其实是向零取整）。
   - 只有当至少有一个操作数是浮点数时，除法才会变成浮点除法，结果才会是浮点数。  
   
> 思考：变量的值存在内存划出的某块区域中，“这块区域存储的值是某某变量的值”以及“有一个变量名字叫某某变量”是存储在另一块内存的区域中的。   
> - 和之前讲的不太一样，但ai告诉我的是这个版本。

# Test

## practice2-2v2

```c
#include <stdio.h>

int main()
{
	int current_time = 0;
	int time_elapse = 0;
	
	printf("请输入起始时间和流逝的时间：");
	scanf("%d %d", &current_time, &time_elapse);
	
	int current_hour = current_time / 100;
	int current_minute = current_time%100;
	int total_current_minute = (current_hour * 60) + current_minute;
	
	int total_arrival_minute = total_current_minute + time_elapse;
	
	int arrival_hour = 	total_arrival_minute / 60;
	int arrival_minute = total_arrival_minute % 60;
	
	int arrival_time = (arrival_hour * 100) + arrival_minute;
	
	printf("%d", arrival_time);
	
	return 0;
}
```

# if

## 计算时间差

```c
#include <stdio.h>

int main()
{
	int hour1, minute1;
	int hour2, minute2;
	
	scanf("%d %d", &hour1, &minute1);
	scanf("%d %d", &hour2, &minute2);

	int ih = hour2 - hour1;
	int im = minute2 - minute1;
	
	if( im < 0){
		im = 60 + im;
		ih--;
	}

	printf("时间差是%d小时%d分。\n", ih, im);

	return 0;
}
```

## if的格式

```c
if(条件成立){
  ...
}
```

## 关系运算，作比较的运算符

计算两个值之间的关系，所以叫做关系运算。  

| 运算符 |意义|
|-----|---|
| ==  |相等|
| !=  |不相等|
| \>  |大于|
| >=  |大于或等于|
| \>  |小于|
| <=  |小于或等于|

### 关系运算的结果

当两个值的关系符合关系运算符的预期时，关系运算的结果为整数1，否则为整数0。  

```c
printf("%d\n",5==3);
printf("%d\n",5>3);
printf("%d\n",5<=3);
```

### 优先级

所有的关系运算符的优先级比算数运算的低，但是比赋值运算的高。  

```c
7 >= 3 + 4;
int r = a>0;
```

关系运算符之间的优先级也并不是相等的。  
判断是否相等的`==`和`!=`的优先级比其他的低，而连续的关系运算是从左到右进行的。  

```c
5 > 3 == 6 > 4;
6 > 5 > 4;
a == b == 6;
a == b > 0;
```

# 找零计算器

找零计算器需要用户做两个操作：输入购买的金额，输入支付的票面，而找零计算器则根据用户的输入做出相应的动作：计算并打印找零，或告知用户余额不足以购买。  
从计算机程序的角度看，这就是意味着程序需要读用户的两个输入，然后进行一些计算和判断，最后输出结果。  

```c
	// 初始化 
	int price = 0;
	int bill = 0;
	// 读入金额和票面 
	printf("请输入金额:");
	scanf("%d", &price);	
	printf("请输入票面:");
	scanf("%d", &bill);
	// 计算找零 
	printf("应该找您：%d\n", bill - price);
	
	return 0;
```

## 注释

以两个斜杠`//`开头的语句把程序分成了三个部分：
1. 初始化；
2. 读入金额和票面；
3. 计算并打印找零。

`//`是C99的注释，ANSIC不支持。  

## 多行注释

`/* */`是可以延续数行的注释，要用多行注释的格式来写。  
多行注释由一堆字符序列`/*`开始，而以`*/`结束。  
也可以用于一行内的注释。  

```c
	int ak = 47 /* 36 */, y = 9;
```

## 判断票面够不够

```c
	// 初始化 
	int price = 0;
	int bill = 0;
	// 读入金额和票面 
	printf("请输入金额:");
	scanf("%d", &price);	
	printf("请输入票面:");
	scanf("%d", &bill);
	// 计算找零
	if ( bill >= price ){
		printf("应该找您：%d\n", bill - price);
	}
	
	return 0;
```
如果没有满足`if`的条件，则跳过大括号继续执行之后的语句。  

## else

```c
#include <stdio.h>

int main()
{
	// 初始化 
	int price = 0;
	int bill = 0;
	// 读入金额和票面 
	printf("请输入金额:");
	scanf("%d", &price);	
	printf("请输入票面:");
	scanf("%d", &bill);
	// 计算找零
	if ( bill >= price ) {
		printf("应该找您：%d\n", bill - price);
	} else {
		printf("您的钱不够。\n");
	}
	
	return 0;
}
```

## 比较数的大小

方案一：
```c
	int a,b;
	
	printf("请输入两个整数：");
	scanf("%d %d", &a, &b);
	
	int max = 0;
	if (a > b){
		max = a;
	}
	if (b > a){
		max = b;
	}
	
	printf("大的那个是%d", max);
	
	return 0; 
```
这种方案没有考虑`a=b`的情况。  

方案二：
```c
	int a,b;
	
	printf("请输入两个整数：");
	scanf("%d %d", &a, &b);
	
	int max = 0;
	if (a > b){
		max = a;
	} else {
		max = b;
	}
		
	printf("大的那个是%d", max);
	
	return 0; 
```

方案三：
```c
	int a,b;
	
	printf("请输入两个整数：");
	scanf("%d %d", &a, &b);
	
	int max = b;
	if (a > b){
		max = a;
	}
	
	printf("大的那个是%d", max);
	
	return 0; 
```

# `if`再探

一个基本的`if`语句 由一个关键字`if`开头，跟上在括号里的一个表示条件的逻辑表达式，然后是一对大括号`{}`之间的若干条语句。  
如果表示条件的逻辑表达式的结果不是零，那么就执行后面跟着的这对大括号中的语句，否则就跳过这些语句不执行，而继续下面的其他语句。  

`if`语句还有另外一种格式，就是没有后面的那对大括号。这种情况下，紧跟着`if`语句的那一行就会被当作`if`语句成立时执行的程序。  
`if`语句这一行结束的时候并没有表示语句结束的`;`，而后面的赋值语句写在`if`的下一行，并且缩进了，在这一行结束的时候有一个表示语句结束的`;`。  
这表明这条赋值语句是`if`语句的一部分，`if`语句拥有和控制这条赋值语句，决定它是否要被执行。

```c
if ( total > amount)
	total += amount + 10;
```
`else`同理。  

例：计算薪水：
```c
const double RATE = 8.25;
const int STANDARD = 40;
double pay = 0.0;
int hours;

printf("请输入工作的小时数：");
scanf("%d", &hours);
printf("\n");

if (hours > STANDARD)
	pay = STANDARD * RATE +
		(hours-STANDARD) * (RATE * 1.5);
else
	pay = hours * RATE;
	
printf("应付工资：%f\n", pay);
```

```c
const int PASS = 60;
int score;

printf("请输入成绩：");
scanf("%d", &score);

printf("你输入的成绩是%d。\n", score);
if ( score < PASS )
	printf("很遗憾，这个成绩没有及格。");
else
	printf("祝贺你，这个成绩及格了。");
printf("再见\n");
```
这种在用户输入后紧接着做一次输出，可以让我们在运行程序的时候可以有效的检验。  

```c
if ( score < PASS )
	printf("很遗憾，这个成绩没有及格。");
else {
	printf("祝贺你，这个成绩及格了。");
	printf("再见\n");
}
```
有`{}`的话可以做这样的调整。  

# 嵌套的`if-else`

## 三个数比较大小

```c
	int a, b, c, max;
	printf("请输入三个整数：");
	scanf("%d %d %d", &a, &b, &c);
	
	if (a > b){
		if (a > c){
			max = a;
		} else {
			max = c;
		}
	} else {
		if (b > c){
			max = b;
		} else {
			max = c;
		}
	}
	
	printf("最大值为%d", max);
	
	return 0;
```

另一种写法：  
```c
	int a, b, c, max;
	printf("请输入三个整数：");
	scanf("%d %d %d", &a, &b, &c);

	if (a>b)
		if (a>c)
			max = a;
		else max = c;
	else
		if (b > c)
			max = b;
		else
			max = c;
	
	printf("最大值为%d", max);
	
	return 0;
```

当`if`的条件满足或者不满足的时候要执行的语句也可以是一条`if`或者`if-else`语句，这就是嵌套的`if`语句。  

## `else`的匹配

`else`总是和最近的那个`if`匹配。  
但是如果加了大括号，情况就会不一样。  

```c
if ( code == READY){
	if ( count < 20)
		printf("一切正常\n");
} else
	printf("继续等待\n");
```

缩进格式并不能暗示`if`和`else`之间的关系。  

```c
if ( code == READY)
	if ( count < 20)
		printf("一切正常\n");
else
		printf("继续等待\n");
```

因此要养成良好的编程习惯要做到：
- 在`if`或`else`后面总是用`{}`；
- 即使只有一条语句的时候。

# 级联的`if-else if`

```c
if ( x < 0 ){
	f = -1;
} else if ( x == 0 ){
	f = 0;
} else if ( x > 5){
	f = 2 * x;
} else {
	f = 3 * x;
}
```
这样`else`对齐方便观看。  

上方代码可以改成另外一种：
```c
if ( x < 0 ){
	printf("%d", -1);
} else if ( x == 0 ){
	printf("%d", 0);
} else if ( x > 5){
	printf("%d", 2 * x);
}
```

这两种写法比较推荐第一种，这种就叫做单一出口。  
第一种写法中不会打扰到之后对`f`的使用，代码只是为了算出`f`的结果，最终是将`f`给别人看，还是参与计算之类的都可以，比较灵活。  
而第二段代码就写死了`if`和`else`的结果，就是执行`printf()`。  

# 多类分支：`switch-case`

```c
	int type;
	
	scanf("%d", &type);
	
	if (type == 1)
		printf ("您好");
	else if (type == 2)
		printf ("早上好");
	else if (type == 3)
		printf ("晚上好");
	else if (type == 4)
		printf ("再见");
	else
		printf("啊，什么啊？");	 
	
	return 0;
```
在这种代码中，如果运气好，对比一次就可以出结果，但是如果运气不好，要一直对比才能出结果。  
可以使用`switch-case`

```c
	switch (type) {
		case 1:
			printf("您好");
			break;
		case 2:
			printf("早上好");
			break;
		case 3:
			printf("晚上好");
			break;
		case 4:
			printf("再见");
			break;
		default:
			printf("啊，什么啊？");
	}
```

需要注意的几个点：
1. 控制表达式只能是整数型的结果（`switch ()`括号中的就是控制表达式)；
2. 常量可以是常数，也可以是常数计算的表达式；

## `break`

`switch`语句可以看作是一种基于计算的跳转，计算控制表达式的值后，程序会跳转到相匹配的`case`（分支标号）处。  
分支标号只是说明`switch`内部位置的路标，在执行完分支中的最后一条语句后，如果后面没有`break`，就会顺序执行到下面的`case`里去，直到遇到一个`break`，或者`switch`结束为止。  

一般来说会为每一个`case`配置一个`break`，但有时候想让两个甚至更多的`case`能做一个相同的事情才会利用`break`的特性不这么做。

### 成绩转换

要求编写程序将一个百分制成绩转换为五分制成绩。转换规则：
- 大于等于90分为A;
- 小于90且大于等于80为B;
- 小于80且大于等于70为C;
- 小于70且大于等于60为D;
- 小于60为E。

```c
	printf("输入成绩：");
	
	int grade;
	scanf("%d", &grade);
	grade /= 10;
	
	switch (grade){
		case 10:
		case 9:
			printf("A\n");
			break;
		case 8:
			printf("B\n");
			break;
		case 7:
			printf("C\n");
			break;
		case 6:
			printf("D\n");
			break;
		default:
			printf("F\n");
			break;
	}
	
	return 0;
```

这段代码不符合”单一出口“的原则，因为我们还没学过字符或字符串数据的处理。  

# 循环

## 数数几位数

程序要读入一个4位以下（含4位）的正整数，然后输出这个整数的位数。如：输入：352，输出：3、  
计算机处理的方式是判断数的范围来决定它的位数。像352就是3位数是一定在100和999之间的。  

```c
	int x;
	int n = 1;
	
	scanf("%d", &x);
	
	if (x > 999){
		n = 4;
	} else if (x > 99){
		n = 3;
	} else if (x > 9){
		n = 2;
	}
	
	printf("%d\n", n);
```

因为题目明确了4位数及以下的正整数，所以可以简化一些判断。  
因为是从高处往下判断，所以不需要判断上限了。  
范围小的话可以这么用。  

## `while`循环

```c
	int x;
	int n = 0;
	
	scanf("%d", &x);
	
	n++;
	x /= 10;
	
	while (x > 0){
		n++;
		x /= 10;
	}
	
	printf("%d\n", n);
	
	return 0;
```

`if`和`while`只要把`if`换成`while`就行，其余格式上没有什么区别。  
`if`是一次行动 ，`while`是反复去做的。  
`while`括号中的部分被称为循环体，循环体内要有改变条件的机会，否则循环会出不来。

```c
	int x;
	int n = 0;
	
	scanf("%d", &x);
	
	n++;
	x /= 10;
	
	while (x > 0){
		n++;
	}
```
像以上代码会在判断`x>0`以及`n++`两步之间无限循环。  

### 验证

`n++; x /= 10;`，可以通过验证的办法来确定是否可以把它删掉。

测试程序常常使用边界数据，如有效范围两端的数据、特殊的倍数等。比如：个位数，10，0，负数。  
也可以在程序适当的地方插入`printf()`来输出变量的内容，这样就可以看到具体的进展。  

## `do-while`循环

在进入循环的时候不做检查，而是在执行完一轮循环体的代码之后，再来检查循环的条件是否满足，如果满足则继续下一轮循环，不满足则结束循环。  

`while`和`do-while`的区别是什么时候判断条件，后者是在循环体执行结束的时候才来判断条件。  
也就是说，无论如何，循环都会执行至少一遍，然后再来判断条件。  
与`while`循环相同的是，条件满足时执行循环，条件不满足时结束循环。  

## 猜数

让计算机来想一个数，然后让用户来猜，用户没输入一个数，就告诉它是大了还是小了，直到用户猜中为止，最后还要告诉用户猜了多少次。

计算机提出一个数并存到变量之中；  
用户输入一个数；  
计算机对比并增加一次次数；  
如果不相等就继续循环到第2步，大就输出大了，小就输出小了；  
相等则退出循环，计算机输出次数和猜中。  

1. 计算机随机想一个数，记在变量number里；
2. 一个负责及次数的变量count初始化为0；
3. 让用户输入一个数字a；
4. count递增（加一）；
5. 判断a和number的大小关系，如果a大，就输出”大“；如果a小就输出”小“；
6. 如果a和number是不相等的（无论大还是小），程序转回第3步；
7. 否则，程序输出“猜中”和次数，然后结束。  

```c
	srand(time(0));
	int number = rand()%100+1;
	int count = 0;
	int a = 0;
	printf("我已经想好了一个1到100之间的数。\n");
	
	do {
		printf("猜猜这个1到100之间的数： \n");
		scanf("%d", &a);
		count ++;
		if (a > number) {
			printf("你猜的数大了。\n"); 
		} else if (a < number){
			printf("你猜的数小了。\n");
		}
	} while (a != number);
	
	printf("太好了，你猜了%d次就猜对了答案。\n", count);
```

## 算平均数

让用户输入一系列的正整数，最后输入-1表示输入结束，然后程序计算出这些数字的平均数，输出输入的数字的个数和平均数。  

需要考虑的：
1. 变量；
2. 算法；
3. 流程图；
4. 程序。

### 变量

我们需要一个记录读到的整数的变量。  

平均数怎么算？  
只需要每读到一个数，就把它加到一个累加的变量里，到全部数据读完，再拿它去除读到的数的个数就可以了。  

一个变量记录累加的结果，一个变量记录读到的数的个数。  

### 算法

1. 初始化变量`sum`和`count`为0；
2. 读入`number`；
3. 如果`number`不是-1，则将`number`加入`sum`，并将`count`加1，回到2；
4. 如果`number`是-1，则计算和打印出`sum/count`（注意换成浮点来计算）。

```c
	int sum = 0;
	int count = 0;
	int number;
	
	do{
		printf("请输入正整数：");
		scanf("%d", &number);
		
		if ( number != -1){
		sum += number;
		count++;			
		}				
	} while (number != -1); 
	
	printf("%f", 1.0*sum/count);
```

也可以改成这样的，这样就可以只做一次判断。
```c
	printf("请输入正整数：");
	scanf("%d", &number);
	
	while (number != -1){
		sum += number;
		count++;	
		printf("请输入正整数：");
		scanf("%d", &number);	
	}
```

## 整数的分解

一个整数是由1至多位数字组成的，如何分解出整数的各个位上的数字，然后加以计算。  
- 对一个整数做`%10`的操作，就得到它的个位数；
- 对一个整数做`/10`的操作，就去掉了它的个位数；
- 然后再对第2步的结果做`%10`，就得到原来数的十位数了；
- 依次类推。

### 数的逆序

输入一个正整数，输出逆序的数。  

```c
	int x;
	scanf("%d", &x);
	
	int digit;
	int ret = 0;
	
	while (x > 0){
		digit = x%10;
		ret = ret * 10 + digit;
		printf ("x=%d, digit=%d, ret=%d\n", x, digit, ret);
		x /= 10;
	}
	
	printf("%d", ret);
```

这是另一种写法，使用`printf()`。 
```c
	int x;
	scanf("%d", &x);
	
	int digit;
	int ret = 0;
	
	while (x > 0){
		digit = x%10;
		printf("%d", digit);
		ret = ret * 10 + digit;
		// printf ("x=%d, digit=%d, ret=%d\n", x, digit, ret);
		x /= 10;
	}
	
	// printf("%d", ret);
```

# `for()`循环

## 阶乘

n! = 1x2x3x4x5x...xn  
写一个程序，让用户输入n，然后计算输出n!。  

变量：
1. 读用户的输入需要一个`int`的`n`；
2. 计算的结果需要用一个变量保存，可以是`int`的`factor`；
3. 在计算中需要有一个变量不断地从1递增到n，那可以是`int`的`i`。

```c
	int n, factor, i;
	i = 0;
	factor = 1;
	
	scanf("%d", &n);
	
	i++;
	
	while (i <= n) {
		factor = factor * i;
		i++;
	}
	
	printf("%d", factor);
	
	return 0;
```

也可以使用`for()`改写，如下：  
```c
	for ( i=1; i<=n; i++ ) {
		factor *= i ;
	}
```	

## `for()`循环的格式

`for()`中第一个是初始条件，第二个是循环继续的条件，也就是循环条件，第三个是循环完每一轮要做的事情。  
`for()`循环像一个计数循环：设定一个计数器，初始化它，然后再计数器到达某值之前，重复执行循环体，  
而每执行一轮循环，计数器值以一定步进进行调整，比如加1或者减1或者乘2等等。  

```c
for ( i=0; i<5; i++) {
	printf("%d", i);
} 
```
`for()`可以读成对于，上文代码可以读成：对于一开始的`i=0`，当`i<5`时，重复做循环体，每一轮循环在昨晚循环体内语句后，使得`i++`。  

做求和的程序时，记录结果的变量应该初始化为0，而做求积的变量时，记录结果的变量应该初始化为1。  

循环控制变量`i`只在循环里被使用了，循环外面它没有任何用处。因此，我们可以把变量`i`的定义写到`for()`语句里面去。  
但这种写法只有在C99中才能用，在编译器中有时候需要加一些特殊选项才可以使用。
```c
for ( int i=1; i<=n; i++) {
	fac *= i;
} 
```

## try

像上文代码中运行第一次会有一个1*1，这种是毫无意义的，那能不能把`int i = 1;`改成`int i = 2;`呢？  
```c
int fact = 1;
for ( int i=2; i<=n; i++) {
	fact *= i;
}
```
答案是可以，这样如果输入1，那`for()`判断不符合循环条件会直接跳过，此时`fact = 1;`，所以输出的还是1的阶乘。  

除了从2开始乘，直到乘n，还可以从n开始，直到乘2。  
```c
int fact = 1;
for ( int i=n; i>=2; i--) {
	fact *= i;
}
```

在上文代码中`i`的值是从n到2的，那这样可以试着去除`i`变量，在`for()`中直接使用`n`，让`n`减到2为止。  
这样可以省掉那个`i`，但是最后输出的时候哦还是需要一个变量来储存最开始的`n`的值。  
```c
int fact = 1;
int i = n;

for ( int n=n; n>=2; n--) {
	fact *= n;
}

printf("%d!=%d\n", i, fact);
```
在上文代码中，`n=n`相当于什么事都没做，那其实是可以直接省略掉的。对于`for()`循环来说，三个表达式每个表达式都是可以省略的，但是分号不能省略。  

## 循环次数

对于代码`for (i=0; i<n; i++)`来说循环的次数是n，而循环结束以后，`i`的值是n。  
循环的控制变量`i`，是选择从0开始还是从1开始，是判断`i<n`还是判断`i<=n`，对循环的次数，循环结束后变量的值都有影响。  

```c
for ( int i=1; i<=n; i++) {
	fact *= i;
}

int i=1;
while (i<=n){
	fact *= i;
	i++;
}
```
上文的`for()`和`while()`其实是一样的，可以相互转换。  

## 循环方法的选择

在`for()`、`while()`、`do-while()`三种方法中做选择，一般来说：  
- 如果有固定次数，选择`for()`；
- 如果必须执行依次，选择`do-while()`；
- 其他情况用`while()`。

## 循环控制

### 素数

素数是只能被1和自己整除的数，不包括1。  
2，3，5，7，11....  

判断一个数是不是素数，就用1和它本身以外的数去除它试试。  
```c
	int x;
	scanf("%d", &x);
	int isPRrime = 1;
	
	int i;
	for ( i=2; i<x; i++) {
		if ( x % i == 0){
			isPrime = 0;
			break;
		}
	}
	
	if ( isPrime == 1) {
		printf("是素数\n");	
	} else {
		printf("不是素数\n");
	}
```
在`for()`循环中的`if()`中加一个`break`，`break`可以跳出循环进入循环之后的语句中，无论是哪种循环。  
另外有一种`continue`，可以跳过循环这一轮剩下的语句进入下一轮循环。  

```c
	int x;
	scanf("%d", &x);
	// int isPRrime = 1;
	
	int i;
	for ( i=2; i<x; i++) {
		if ( x % i == 0){
			isPrime = 0;
			break;
		}
	}
	
	// if ( isPrime == 1) {
	if ( i == x) {
		printf("不是素数\n");	
	} else {
		printf("是素数\n");
	}
```
可以改成这样，利用`i`和`x`之间的关系省去变量`isPrime`。

## 嵌套循环

### 输入100以内的素数

```c
	int x;
	
	for ( x = 2; x < 100; x++ )
	{
		int i;
		int isPrime = 1;
		
		for ( i = 2; i < x; i++ ) {
			if ( x % i == 0) {
				isPrime = 0;
				break;
			}
		}
		if ( isPrime == 1) {
			printf("%d ", x);
		}
	}
```

```c
int x;
x = 2;
int cnt = 0;

while ( cnt < 50) {
	int i;
	int isPrime = 1;
	for ( i=2; i<x; i++) {
		if ( x % i == 0) {
			isPrime = 0;
			break;
		} 
	
	if ( isPrime == 1) {
		printf("%d", x);
		cnt++;
	}
	x++;
	}
}
```
如果是要改成输出50个素数的话，就可以这么写。  

## 离开多重循环

### 凑硬币

如何用1角、2角和5角的硬币凑出10元以下的金额呢。  

```c
	int x;
	int one, two, five;
	
	x = 2;
	for ( one = 1; one < x*10; one++ ) {
		for ( two = 1; two < x*10/2; two++ ) {
			for ( five = 1; five < x*10/5; five++ ) {
				if ( one + two*2 + five*5 == x*10 ) {
					printf("可以用%d个1角加%d个2角加%d个5角得到%d元\n", one, two, five, x);
				}
			}
		}
	}
```

如果想要输出一个方案就停止，可以使用`break`以及`goto`。  

`break`：
```c
	int x;
	int one, two, five;
	int exit = 0;
	
	x = 2;
	for ( one = 1; one < x*10; one++ ) {
		for ( two = 1; two < x*10/2; two++ ) {
			for ( five = 1; five < x*10/5; five++ ) {
				if ( one + two*2 + five*5 == x*10 ) {
					printf("可以用%d个1角加%d个2角加%d个5角得到%d元\n", one, two, five, x);
					exit = 1;
					break;
				}
			}
			if ( exit == 1 ) break;
		}
		if ( exit == 1 ) break;
	}
```

`goto`：
```c
	int x;
	int one, two, five;
	
	x = 2;
	for ( one = 1; one < x*10; one++ ) {
		for ( two = 1; two < x*10/2; two++ ) {
			for ( five = 1; five < x*10/5; five++ ) {
				if ( one + two*2 + five*5 == x*10 ) {
					printf("可以用%d个1角加%d个2角加%d个5角得到%d元\n", one, two, five, x);
					goto out;
				}
			}
		}
	}
out:
```

## 前n项求和

```c
	int n;
	scanf("%d", &n);
	double sum = 0.0;
	int i;
	
	for ( i = 1; i <= n; i++) {
		sum = sum + 1.0/i;
	}
	
	printf("%f", sum);
```

也可以这样写，让式子+和-来回切换。  
```c
	int n;
	scanf("%d", &n);
	double sum = 0.0;
	int i;
	int sign = 1;
	
	for ( i = 1; i <= n; i++) {
		sum = sum + sign*1.0/i;
		sign = -sign;
	}
	
	printf("%f", sum);
```

## 正序分解整数

输入一个非负整数，正序输出它的每一位数字。  
例：输入：12345，输出：1 2 3 4 5。  

```c
	int x;
	scanf("%d", &x);
	
	int mask = 1;
	int t = x;
	
	while ( t > 9 ) {
		t /= 10;
		mask *= 10;
	}
	
	printf("x=%d, mask=%d\n", x, mask);
	
	do {
		int d = x / mask;
		printf("%d", d);
		if ( mask > 9) {
			printf(" ");
		}
		x %= mask;
		mask /= 10;
	} while ( mask > 0);
	
	printf("\n");
```

## 最大公约数

输入两个数a和b，输出它们的最大公约数。  
输入： 12 18，输出： 6。  

```c
	int a,b;
	int min;
	
	scanf("%d %d", &a, &b);
	
	if ( a<b) {
		min = a;
	} else {
		min = b;
	}
	
	int ret = 0;
	int i;
	
	for ( i = 1; i < min; i++) {
		if ( a%i == 0 ) {
			if ( b%i == 0 ) {
				ret = i;
			}
		}
	}
	
	printf("%d和%d的最大公约数是%d\n", a, b, ret);
```
这个枚举方法很容易理解，但是效率不高，需要尝试所有的数。  

### 辗转相除法

辗转相除法的效率更高一些。  
1. 如果b等于0，计算结束，a就是最大公约数；
2. 否则，计算a除以b的余数，让a等于b，而b等于那个余数；
3. 回到第一步。

```c
	int a, b, t;
	scanf("%d %d", &a, &b);
	
	while ( b!=0) {
		t = a%b;
		a=b;
		b=t;
	}
	
	printf("gcd=%d\n", a);
```

# 习题

## 4-0

给定不超过6的正整数，考虑从A开始的连续4个数字，请输出所有由它们组成的无重复数字的3位数。  

```c
	int A, B, C;
	int i = 0;
	int z;
	
	scanf("%d", &z);
	
	for (A = z; A <= z+3; A++){
		for ( B = z; B <= z + 3; B++) {
			for ( C = z; C <= z + 3; C++) {
				if ( A != B){
					if ( B != C) {
						if ( A != C){
							printf("%d", A*100+B*10+C);
							i++;
							if ( i == 6) {
								printf("\n");
								i = 0;
							} else {
								printf(" ");
							}
						}

					}
				}

			}
		}	
	}
```

## 4-1

水仙花数是指一个N位正整数（N>=3），它的每个位上的数字的N次幂之和等于它本身。例：153=1^3+5^3+3^3。本体要求编写程序，计算所有N位水仙花数。（3<=N<=7）
按递增顺序输出所有N位水仙花数，每个数字占一行

```c
	int n;
	scanf("%d", &n);
	
	int f = 1;
	int i = 0;
	for ( ; i < n; i++ ) {
		f *= 10;
	}

	int t;
	for ( t = f/10; t < f; t++ ){
		i = n;
		int m;
		int sum = 0;
		int tf = t;
		
		while ( i > 0) {
			m = tf%10;
			tf /= 10;
			i--;
			
				int j = 1;
				int s = 1;
				while ( j <= n) {
					s *= m;
					j++;
				}
				
			sum += s;
			}
			
		if ( sum == t ) {
		printf("%d\n", t);
		}
	}
```

## 打印九九口诀表

本题要求对任意给定的1位正整数N，输出从1*1到N*N的部分口诀表。  

```c
	int n;
	scanf("%d", &n);
	
	int i = 1;
	int t = 1;
	
	for ( t = 1 ; t <= n; t++ ) {
		
		i = 1;
		
		while ( i < t) {
			printf("%d*%d=%d ", i, t, t*i);
			i++;
		}
		
		printf("%d*%d=%d\n", i, t, t*i);
	
	}
```	

## 统计素数并求和

统计给定整数M和N区间内素数的个数并对它们求和。  
输入格式：输入在一行中给出两个正整数M和N（1 <= M <= N <= 500）。  
输出格式：在一行中顺序输出M和N区间内素数的个数以及它们的和，数字间以空格分隔。  

```c
	int M, N, max, min, t, sta, sum;
	
	scanf("%d %d", &M, &N);
	
	if ( M > N) {
		max = M;
		min = N;
	} else {
		max = N;
		min = M;
	}
	
	sta = 0;
	sum = 0;
	
	for ( t = min; t <= max; t++) {
		
		int i = 2;
		int isPrime = 1;
		
		for ( ; i < t; i++) {
			if ( t%i == 0) {
				isPrime = 0;
				break;
				} 
			}
			
		if ( isPrime == 1) {
			sta++;
			sum += t;
		}
			
		}
	
	printf("%d %d", sta, sum);
```

## 4-4



输入格式：输入第一行中给出2个不超过100的正整数，分别是系统产生的随机数以及猜测的最大次数N，随后每行给出一个用户的输入，直到出现负数为止。  
输出格式：在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。  

程序需要提示大了（“Too big”），还是小了（”Too small“），相等则表示猜到了，如果猜到，则结束程序。  
程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo”；如果3次以内猜到该数，则提示“Lucky You!"；  
如果超过3次但是再N（N>3）次以内（包括第N次）猜到该数，则提示“Good Guess！”；  
如果超过N次都没有猜到 ，则提示“Game Over”，并结束程序。  
如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。  

```c
	int rand = 58;
	int n = 4;
	
	int num = 0;
	int i = 0;
	
	while ( i <= n ) {
		printf ( "请输入：");
		scanf ("%d", &num);
		
		if ( num < 0) {
			printf ("Game Over");
			break;
		}
		
		i++;
		
		if ( num == rand) {
			if ( i == 1) {
				printf ("Bingo!");
				break;
			}
			if ( i <= 3 ) {
				printf ("Lucky You!");
				break;
			}
			if ( i <= n ) {
				printf("Good Guess!");
				break;
			}
		}
		
	}
	
	if ( i > n ) {
		printf ("Game Over");
	}
```

## 5-0 求序列前N项和

编写程序计算序列2/1+3/2+5/3+8/5+...的前N项之和。  
注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。  

输入格式：输入在一行中给出一个正整数N。  
输出格式：在一行中输出部分和的值，精确到小数点后2位。题目保证计算结果不超过双精度范围。  
输入样例： 20  输出样例：32.66

```c
	int l = 2;
	int m = 1;
	
	double sum = 0.0;
	int i = 0;
	int j, k;
	
	int n;
	scanf("%d", &n);
	
	while ( i < n ) {
		sum += 1.0*l/m;
		j = l;
		k = m;
		l = j + k;
		m = j;
		i++;
	}
	
	
	printf ("%.2f", sum);
```

## 5-1 约分最简分式

编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。当分子大于分母时，不需要表达为整数又分数的形式，当分子分母相等时，仍然表达为1/1的分数形式。  

输入格式：输入在一行中给出一个分数，分子和分母中间以斜杠“/”分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0）。
在`scanf()`的格式字符串中加入“/”，让`scanf()`来处理这个斜杠。  

输出格式：在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用“分子/分母”的形式表示分数。

```c
	int l, m;
	int min;
	int i = 2;
	
	scanf ("%d/%d", &l, &m);
	
	if ( l <= m ) {
		min = l;
	} else {
		min = m;
	}
	
	while ( i <= min ) {
		if ( l % i == 0 ) {
			if ( m % i == 0) {
				l = l/i;
				m = m/i;
				i = 1;
			}
		}
		i++;
	}
	
	printf("%d/%d", l, m);
```

## 5-2 念数字

输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出“fu”字。是个数字对应的拼音如下：
|0|ling|
|---|---|
|1|yi|
|2|er|
|3|san|
|4|si|
|5|wu|
|6|liu|
|7|qi|
|8|ba|
|9|jiu|

输入格式：输入在一行中给出一个整数，如：1234；提示：整数包括整数、零和负数。
输出格式：在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如yi er san si。
输入样例： -600    输出样例：fu liu ling ling

### 变量和思路

1. 储存输入整数的变量`x`；
2. 用来数位数的中间变量`t`和代表有多少位的`mask`；
3. 代表每位上的数`type`；

1. 输入整数；
2. 把数变正；
3. 然后倒过来；
4. 提取每个位上的数；
5. 通过每个位上的数定位到对应`switch-case`里的case；

```c
	int x;
	scanf("%d", &x);
	
	if ( x < 0 ) {
		printf ("fu ");
		x = -1 * x;
	}
	
	int t = x;
	int mask = 1;
	
	while ( t > 9 ) {
		t /= 10;
		mask *= 10;
	}
	
	do {
		
		int type = x / mask;
		x %= 10;
		mask /= 10;
		
		switch (type) {
			case 0:
				printf("ling");
				break;
			case 1:
				printf("yi");
				break;
			case 2:
				printf("er");
				break;				
			case 3:
				printf("san");
				break;				
			case 4:
				printf("si");
				break;				
			case 5:
				printf("wu");
				break;				
			case 6:
				printf("liu");
				break;				
			case 7:
				printf("qi");
				break;				
			case 8:
				printf("ba");
				break;				
			case 9:
				printf("jiu");
				break;											
		}
		
			if ( mask > 0) {
				printf (" ");
			}		
		 
	} while ( mask > 0);
```

## 5-3 求a的连续和

输入两个整数a和n，a的范围是[0,9]，n的范围是[1,8]，求数列之和S = a+aa+aaa+aaa+...+aaa....aa（n个a）。  
如a为2、n为8时输出的是2+22+222...+22222222的和。  

输入格式：输入在一行中给出两个整数，先后表示a和n。  
输出格式：在一行中输出要求的数列之和。  
输入样例： 2 4   输出样例：2468

### 变量和思路

1. 变量`a`和`n`；
2. 总和`sum`；
3. 数列中的某个数`t`；
4. 第`i`个数；
5. 位数`s`。

1. 输入两个变量；
2. 计算第一个值；
   加到`sum`；
3. 计算第二个值再加上第一个值；
	计算第二个值是用a*10+a；
	再计算第三个值a*100+1*10+a；
   加到`sum`；
4. 再计算第n个值；
   加到`sum`；
5. 结束。

```c
	int a, n;
	scanf("%d %d", &a, &n);
	
	int sum = 0;
	int t = 0;
	int i = 1;
	int s = 1;
	
	while ( i <= n ) {
		t = a * s + t;
		sum += t;
		i++;
		s *= 10;
	}
	
	printf ("%d", sum);
```

# 数据类型

C语言是有类型的语言，意思是C语言的变量，必须：在使用前定义且确定类型。  
C以后的语言向两个方向发展：
- C++/Java更强调类型，对类型的检查更严格；
- JavaScript、Python、PHP不看重类型，甚至不需要事先定义。  

## 两种观点

- 支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误；
- 反对强类型的观点认为过于强调类型迫使程序员面对底层、实现而非事务逻辑；
- 总的来说，早期语言强调类型，面向底层的语言强调类型；
- C语言需要类型，但是对类型的安全检查并不足够。

## C语言的类型

1. 整数；
   - `char`、`short`、`int`、`long`、`long long`；
2. 浮点数；
   - `float`、`double`、`long double`；
3. 逻辑；
   - `bool`；
4. 指针；
5. 自定义类型。

> `long long`、`long double`、`bool`是C99的。

## 类型有何不同

- 类型名称： `int`、`long`、`double`；  
- 输入输出时的格式化：`%d`、`%ld`、`%lf`；
- 所表达的数的范围：`char` \< `short` \< `int` \< `float` \< `double`；
- 内存中所占据的大小：1个字节到16个字节；
- 内存中的表达形式：二进制数（补码）、编码。

## `sizeof`

`sizeof`是一个运算符，给出某个类型或变量再内存中所占据的字节数。
  - `sizeof(int)`，`sizeof(i)`。
`sizeof`是静态运算符，它的结果再编译时刻就决定了。  
不要在`sizeof`的括号里做运算，这些运算不会做的。  

## 整数类型

`char`、`short`、`int`、`long`、`long long`  
- `char`：1字节（8比特）；
- `short`：2字节；
- `int`：取决于编译器（CPU）；
- `long`：取决于编译器（CPU）；
- `long long`：8字节。

### 整数的内部表达

计算机内部一切都是二进制。  
- 18 -\> 00010010

#### 如何表达负数

1个字节可以表达的数：
  - 00000000 - 11111111 （0-255）；
  
三种方案：
1. 仿照十进制，有一个特殊的标志表示负数；
   - 需要在设计计算机来对二进制数据做加法减法的时候，需要像十进制一样，特别的去判断这个特殊的标志，更不用说更复杂的乘除；
   
2. 取中间的数为0，如10000000表示0，比它小的是负数，比它大的是正数；
   - 在理解其它数时都需要做减法，会让输入输出变得比较复杂；
   
3. 补码。

##### 补码

1是00000001，0是00000000，那-1其实就是与1相加等于0。
此时如果用11111111来代表-1，那 11111111 + 00000001 = 100000000，计算机中如果这个数是8比特的，那就会识别成00000000，就是0了。  

换个角度讲，0-1=-1，所以-1等于：  
(1)00000000 - 00000001 = 11111111。  

11111111被当作纯二进制看待时，是255，被当作补码看待时是-1。  
同理，对于-a，其补码就是0-a，实际上是2^n-a，n是这种类型的位数。  

补码的意义就是拿补码和原码可以加出一个带溢出的零。  
  - 例：11111111 + 00000001 = 100000000

补码的好处在于，在做加法时不用考虑符号，直接加就好。  

### 数的范围

对于一个字节（8位），可以表达的是00000000 - 11111111.  
其中：
- 00000000 -\> 0;
- 11111111 ~ 10000000 -\> -1 ~ -128;
- 00000001 ~ 01111111 -\> 1 ~ 127。

### unsigned

`U/u`表示`unsigned`，用于证书字面量后缀，告诉编译器字面量是**无符号整数**。  
用途：不是为了扩展数值范围，而是为了做纯二进制运算和位操作。  
字面量带`U`后，表达式参与运算时，可能会把其他类型转换为`unsigned`（类型提升规则）。

`L/l`表示`long`，用于整数字面量后缀，告诉编译器字面量类型为`long`。  
可以确保数字足够大的时候不会溢出；  
`long x = 3000000000;` 中如果没有`L`，3000000000可能会先被当成`int`，在赋值前就出错。
  - 即使加了`L`，如果是windows 32位这种，`long`就也是32位，最大2147483647，3000000000溢出导致报错。

> 用`U`和`L`可读性会更好。

### 整数的输入输出

只有两种形式：`int`或`long long`。  
所有小于`int`的例如`short`和`char`都用和`int`相同的办法输入输出整数，所有比`int`来得大的都用`long long`一样的。  
- `%d: int`
- `%u: unsigned`
- `%ld: long long`
- `%lu: unsigned long long`

> `%d`表示想要输出的是一个十进制的东西。

### 选择整数类型

- 为什么整数要有那么多种？
  - 为了准确表达内存，做底层程序的需要。
- 没有特殊需要，就选择`int`。
  - 现在的CPU的字长普遍是32位或64位，一次内存读写就是一个`int`，一次计算也是一个`int`，选择更短的类型不会更快，甚至可能更慢；
  - 现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个`int`的大小（虽然`sizeof`告诉你更小）；
  - 如果是在做面向硬件的底层设计，那硬件要求用什么类型就用什么类型。
- unsigned与否只是输出的不同，内部计算是一样的。

## 浮点类型

|类型|字长|范围|有效数字|scanf|printf|
|---|---|---|---|---|---|
|float|32|±(1.20x10^-38~3.40x10^38),0,±inf,nan|7|%f|%f,%e|
|double|64|±(2.2x10^-308~1.79x10^308),0,±inf,nan|15|%lf|%f,%e|

### 输出精度

在%和f之间加上.n可以指定输出小数点后几位，这样的输出是做四舍五入的。  

### 浮点数的范围和精度

- `printf()`输出`inf`表示超过范围的浮点数：±∞；
- `printf()`输出`nan`表示不存在的浮点数。

在C/C++中：整数除以0是未定义行为。  
浮点数除以0，遵循 IEEE 754浮点数标准，结果是：
  - 正数/0 → +∞（正无穷）  
  - 负数/0 → -∞（负无穷）
  - 0/0 → nan

在浮点数的设计中，把正负无穷大和`nan`作为3种特殊的值定义在浮点数的值里了。  

#### 浮点数的精度

做精细的运算时不建议用浮点数，浮点数本身有有效数字这个概念，在做计算的过程中会累计误差。  

带有小数点的数的字面量是`double`而非`float`，`float`需要用`f`或者`F`后缀来表明身份。  

比较两个浮点数是否相等：
- `f1 == f2`可能失败；
- `fabs(f1-f2)<le-12`
  - 算出两个浮点数相减的绝对值并和一个很小的数相比，这个很小的数只要比能够表达的精度来的小就可以。

### 浮点数的内部表达

浮点数在计算时是由专用的硬件部件实现的；  
计算`double`和`float`所用的方法和部件是一样的。  

浮点数用1位表达正负，11位表达整数部分，52位表达分数部分。（不准确，可以先大致这么理解）  
浮点数内部不是二进制数，而是一个编码的形式，在计算的时候cpu都是带着专门的浮点计算的硬件的；  
在计算时，实际上会把对应的编码数交给那个专门计算的硬件，那个硬件会把这个数解开来，然后做计算，做完计算再编成编码返回。  

### 选择浮点类型

如果没有特殊需要，只是用`double`。  
现代CPU能直接对`double`做硬件运算，性能不会比`float`差，在64位的机器上，数据存储的速度也不比`float`慢。  

## 字符类型

`char`是一种整数，也是一种特殊的类型：字符。这是因为：  
- 用单引号表示的字符字面量：`'a'`,`'1'`；
- `"`也是一个字符；
- `printf()`和`scanf()`里用`%c`来输入输出字符。  

### 字符的输入输出

如何输入`'1'`这个字符给`char c`？
  - `scanf("%c", &c);` -\> 1
  - `scanf("%d", &i); c=i;` -\> 49
`'1'`的ASCII编码是49，所以当`c == 49`时，它就代表`'1'`。

### 混合输入

`scanf("%d %c", &i, &c);`
`scanf("%d%c", &i, &c);`

像第二种没有空格的话，如果是输入的`12 a`，那读取到的就是`12`和` `。  
第一种有空格，输入的`12 a`或`12a`都能正确读取，不会读取到空格。  

### 字符计算

```c
char c = 'A';
c++;
```
得到的会是`B`。  
一个字符加一个数字得到ASCII码表种那个数之后的字符。  
两个字符的减，得到它们在表中的距离。  

### 大小写转换

字母在ASCII表中是顺序排列的；  
大写字母和小写字母是分开排列的，并不在一起。  
`'a'-'A'`可以得到两段之间的距离，于是  
  - `a+'a'-'A'`可以把一个大写字母变成小写字母，而
  - `a+'A'-'a'`可以把一个小写字母变成大写字母。

## 逃逸字符

用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符，这两个字符组合起来，就组成了一个字符。  
`printf("请分别输入身高的英尺和英寸，"
	"如输入\"5 7\"表示5英尺7英寸：");`
在上文代码中`\"`代表了字符`"`，因为如果在双引号之间出现了双引号，就会觉得第一个双引号和第二个双引号之间的是一个字符串，  
但其实并不是这样的，第一个双引号和第四个双引号之间才是字符串。  

|字符|意义|
|---|---|
|\b|回退一格|
|\t|到下一个表格位|
|\n|换行|
|\r|回车|
|\"|双引号|
|\'|单引号|
|\\|反斜杠本身|

`table`的意思是行当中的固定位置，而不是固定大小的字符数量。

## 自动类型转换

当运算符的两边出现不一致的类型时，会自动转换成较大的类型。  
  - 大的意思是能表达的数的范围更大；
  - `char` -\> `short` -\> `int` -\> `long` -\> `long long`
  - `int` -\> `float` -\> `double`

对于`printf()`，任何小于`int`的类型会被转换成`int`；`float`会被转换成`double`；  
但是`scanf()`不会，要输入`short`，需要`%hd`。  

### 强制类型转换

要把一个量强制转换成另一个类型（通常是较小的类型），需要：
- （类型）值；
   - `(int)10.2`

强制类型转换只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变。  

```c
int a = 5;
printf("%d\n", a);        // 5
printf("%f\n", (double)a); // 5.000000
printf("%d\n", a);        // 5
```

强制类型转换的优先级高于四则运算，如果四则运算是放在括号里的，就先算四则运算。  

```c
double a = 1.0;
double b = 2.0;
int i = (int)a / b;
printf("%d", i);

i = 0;
```

> 赋值只做一件事，就是把右边的结果值，转换成左边变量的类型，再存进去。  
  在学习阶段可以认为赋值不适用自动类型转换的规则。

## `bool`

并不算是C语言的原生文件，要先包含一个头文件才能用。  
头文件的名字是`#include<stdbool.h>`，之后就可以使用`bool`和`true`、`false`。  

## 逻辑运算

逻辑运算的结果是0表示假（false），非0表示真（true）。  
逻辑量是关系运算或逻辑运算的结果。其实就是约等于判断的结果。    

|运算符|描述|示例|结果|
|---|---|---|---|
|`!`|逻辑非|`!a`|如果a是true结果就是false，如果a是false结果就是true|
|`&&`|逻辑与|`a && b`|如果a和b都是true，结果就是true；否则就是false|
|`||`|逻辑或|`a||b`|如果a和b有一个是true，结果为true；两个都是false，结果为false|

### try

如果要表达数学中的区间，如：4\<x\<6或者4\<=x\<=6，该如何写C的表达式。  
1. `x>4 && x<6`;
2. `x>=4 && x<=6`

如何判断一个字符c是否是大写字母。
  - `c>='A' && c<='Z'`

### 理解`!`

```c
if (!x) {
printf("x 是 0\n");
}
```

完全等价于：  
```c
if ( x == 0 );
```

### 运算符优先级

`i > && > ||`

逻辑运算符普遍低于关系运算符，但是`!`是单目运算符，单目运算符的优先级是高于双目运算符的。  


|优先级|运算符|结合性|
|---|---|---|---|
|1|`()`|从左到右|
|2|`!` `+` `-` `++` `--`|从右到左（单目的`+`和`-`）|
|3|`*` `/` `%`|从左到右|
|4|`+` `-`|从左到右|
|5|`<<` `>>`|从左到右|
|6|`<` `<=` `>` `>=`|从左到右|
|7|`==` `!=`|从左到右|
|8|`&&`|从左到右|
|9| `||`|从左到右|
|10| `=` `+=` `-=` `*=` `/=` `%=`|赋值运算|从右到左|

> 单目`+``-`是“符号运算符”，用来表示“正号/负号”，只作用在一个操作数上。

### 短路

逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算。  
  - `a == 6 && b == 1;`
  - `a == 6 && b += 1;`
对于`&&`来说左边是false时就不做右边了；  
对于`||`来说左边是true时就不做右边了。  

不要把赋值包括复合赋值组合进表达式，这样短路就影响不到程序的写作了。  

## 条件运算符

`count = (count > 20) ? count - 10 : count + 10;
问号之前是条件，问号后分别是条件满足时的值和条件不满足时的值。  

这是一个早期遗留下的东西，表面上看这是把`if-else`改写成了一个易懂的东西，但有时候会带来很大的麻烦。  
像是有复合赋值的情况会大大增加表达的复杂性，更不用说多个条件表达式互相嵌套。  

### 优先级

条件运算符的优先级高于赋值运算符，但是低于其他运算符。  

条件运算符是自右向左结合的，先看分支再看总的地方：  
`w < x ? x + w : w < y ? x : y`

## 逗号运算

逗号在c语言中是一个运算符。  
逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。  
逗号的优先级是所有运算符中最低的，所以它两边的表达式会先计算；  
逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。  

如果在`for()`中想要放入多个计算，那就可以使用逗号运算符，逗号运算符目前来说就只有这一个用处。
  - `for ( i = 0 , j = 10; i < j; i++ , j-- );`
    - 其实在这里就是用逗号让`i = 0`和`j = 10`同时作为初始条件，让`i++`和`j--`同时作为循环操作。
































































































































































